ADD FUNCTIONALITY - END-TO-END (INLINE + MULTI-ADD)

Goal
- Add empty rows inline in MDC tables (OData V4)
- Multi-row creation (press Add multiple times)
- Save commits all; Cancel discards all newly added rows

Where the code lives
- webapp/utility/CustomUtility.js  (main logic)
- webapp/controller/Home.controller.js  (exposes helpers to controller scope)
- Fragments: existing Add buttons call onAdd (no extra changes required)

Main functions (CustomUtility.js)
1) onAdd(oEvent)
   - Detects current table (Customers/Employees/Opportunities/Projects/SAPIdStatuses)
   - Gets MDC list binding: getRowBinding() or getBinding("items"|"rows")
   - Creates transient context: binding.create(emptyRowData)
   - Accumulates edit paths in model "edit" → editingPath (comma-separated)
     • First add → mode = "add"
     • Second+ add → mode = "add-multi"
   - Buttons: Save/Cancel enabled; Edit/Delete disabled; Add stays enabled (multi-add)

2) _executeAddWithRetry(oTable, oBinding, sTableId, oExistingContext)
   - Fallback when binding is not ready; mirrors onAdd behavior

3) _getRowBinding(oTable)
   - Returns MDC row/list binding safely (row/items/rows)

4) _resolveContextByPath(oTable, sPath)
   - Finds a context by its path (supports transient $uid paths)
   - Looks in binding contexts, then inner responsive table items

5) _createEmptyRowData(sTableId)
   - Returns sensible defaults per table; marks rows as: _isNew = true, isEditable = true

Save flow (onSaveButtonPress)
- Reads edit>/mode and edit>/editingPath
- If mode = "add-multi": splits paths, resolves all contexts, pushes input values, submits in one batch
- Submits with group "changesGroup" (see manifest.json model updateGroupId)
- Clears edit state, resets buttons, refreshes table

Cancel flow (onCancelButtonPress)
- If mode = "add-multi": resolves all paths and for each context:
  • If transient/new → context.delete()
  • Else, if _originalData exists → restore properties
- Does NOT call global model.resetChanges() (prevents nuking other edits)
- Clears edit state, disables Save/Cancel, re-enables Add, refreshes table

Controller wiring (Home.controller.js)
- Exposes helpers from CustomUtility so controller methods can call them:
  • _createEmptyRowData
  • _executeAddWithRetry
  • _resolveContextByPath
  • _getRowBinding

Button behavior (per table)
- Save: saveButton[/_emp/_oppr/_proj/_sap]
- Cancel: cancelButton[/_emp/_oppr/_proj/_sap]
- Add: remains enabled during add to allow multi-row creation
- Edit/Delete: disabled while adding

OData & persistence
- Creates use OData V4 ListBinding.create(...)
- Save uses oModel.submitBatch('changesGroup') → backend $batch
- With in-memory DB, data resets on restart; use SQLite/HANA for persistence

How to test
1) Multi-add: Click Add 3 times → editingPath holds 3 comma-separated paths → Save → single $batch with 3 creates
2) Multi-cancel: Click Add 2 times → Cancel → both transient rows removed, buttons reset
3) Network: DevTools → Network → check /odata/v4/my/$batch on Save

Notes
- MDC table APIs differ from sap.m.Table; ListBinding.create is the supported V4 way
- Context resolution supports transient paths; Save/Cancel work even without row selection

=== CODE SNIPPETS ===

1) onAdd function (CustomUtility.js)
```javascript
onAdd: function (oEvent) {
    console.log("=== [ADD] Function called ===");
    
    try {
        // Determine which table this add is for
        let sTableId = "Customers"; // Default fallback
        if (oEvent && oEvent.getSource) {
            const sButtonId = oEvent.getSource().getId().split("--").pop();
            console.log("Add Button ID:", sButtonId);
            // Map button IDs to table IDs
            if (sButtonId.includes("cus")) sTableId = "Customers";
            else if (sButtonId.includes("emp")) sTableId = "Employees";
            else if (sButtonId.includes("oppr")) sTableId = "Opportunities";
            else if (sButtonId.includes("proj")) sTableId = "Projects";
            else if (sButtonId.includes("sap")) sTableId = "SAPIdStatuses";
        }

        console.log("Table ID:", sTableId);
        const oTable = this.byId(sTableId);
        if (!oTable) {
            console.error("Table not found:", sTableId);
            sap.m.MessageBox.error(`Table '${sTableId}' not found.`);
            return;
        }

        console.log(`=== [ADD] Starting add new row for ${sTableId} ===`);

        // Get table binding with retry logic (prefer MDC row binding)
        let oBinding = (oTable.getRowBinding && oTable.getRowBinding())
            || oTable.getBinding("items")
            || oTable.getBinding("rows");
        console.log("Primary binding check:", oBinding);
        
        if (!oBinding) {
            console.log("Primary binding not found, retrying shortly...");
            setTimeout(() => {
                const oRetryBinding = (oTable.getRowBinding && oTable.getRowBinding())
                    || oTable.getBinding("items")
                    || oTable.getBinding("rows")
                    || oTable.getBinding("data");
                if (oRetryBinding) {
                    console.log("Binding found on retry:", oRetryBinding);
                    this._executeAddWithRetry(oTable, oRetryBinding, sTableId);
                } else {
                    sap.m.MessageBox.error("No data binding available. Please ensure the table is fully loaded and try again.");
                }
            }, 400);
            return;
        }
        
        // Create new empty row data and create via V4 ListBinding.create
        const oNewRowData = this._createEmptyRowData(sTableId);
        console.log("New row data:", oNewRowData);
        const oNewContext = oBinding.create(oNewRowData);

        if (!oNewContext) {
            console.error("Failed to create new context");
            sap.m.MessageBox.error("Failed to create new row.");
            return;
        }

        console.log("New context created:", oNewContext.getPath());

        // Set the new row in edit mode
        const oEditModel = this.getView().getModel("edit");
        if (!oEditModel) {
            // Create edit model if it doesn't exist
            const oEditModelData = {
                editingPath: "",
                mode: null
            };
            this.getView().setModel(new sap.ui.model.json.JSONModel(oEditModelData), "edit");
        }

        const oEditModelFinal = this.getView().getModel("edit");
        const sExistingPaths = oEditModelFinal.getProperty("/editingPath") || "";
        const sNewPath = oNewContext.getPath();
        let aPaths = sExistingPaths ? sExistingPaths.split(",").filter(Boolean) : [];
        if (!aPaths.includes(sNewPath)) {
            aPaths.push(sNewPath);
        }
        oEditModelFinal.setProperty("/editingPath", aPaths.join(","));
        oEditModelFinal.setProperty("/mode", aPaths.length > 1 ? "add-multi" : "add");

        // Enable Save and Cancel buttons, disable others
        const buttonMap = {
            "Customers": { edit: "btnEdit_cus", delete: "btnDelete_cus", save: "saveButton", cancel: "cancelButton", add: "btnAdd" },
            "Employees": { edit: "Edit_emp", delete: "Delete_emp", save: "saveButton_emp", cancel: "cancelButton_emp", add: "btnAdd" },
            "Opportunities": { edit: "btnEdit_oppr", delete: "btnDelete_oppr", save: "saveButton_oppr", cancel: "cancelButton_oppr", add: "btnAdd" },
            "Projects": { edit: "btnEdit_proj", delete: "btnDelete_proj", save: "saveButton_proj", cancel: "cancelButton_proj", add: "btnAdd" },
            "SAPIdStatuses": { edit: "btnEdit_sap", delete: "btnDelete_sap", save: "saveButton_sap", cancel: "cancelButton_sap", add: "btnAdd" }
        };

        const config = buttonMap[sTableId];
        this.byId(config.save)?.setEnabled(true);
        this.byId(config.cancel)?.setEnabled(true);
        this.byId(config.edit)?.setEnabled(false);
        this.byId(config.delete)?.setEnabled(false);
        this.byId(config.add)?.setEnabled(true); // Keep Add enabled for multi-row creation

        // Clear any existing selection
        oTable.clearSelection();

        // Refresh table to show new row in edit mode
        oTable.getBinding("items")?.refresh();

        // Force refresh to ensure edit mode is applied
        setTimeout(() => {
            oTable.getBinding("items")?.refresh();
            console.log(`[ADD] New row added and in edit mode for ${sTableId}`);
        }, 100);

        sap.m.MessageToast.show("New row added. You can now fill in the data.");

    } catch (error) {
        console.error("Add row error:", error);
        sap.m.MessageBox.error("Failed to add new row: " + error.message);
    }
},
```

2) _createEmptyRowData function (CustomUtility.js)
```javascript
_createEmptyRowData: function (sTableId) {
    console.log("Creating empty row data for table:", sTableId);
    
    const emptyDataMap = {
        "Customers": {
            sapcustId: 0,
            sfdccustomerId: 0,
            name: "",
            city: "",
            country: "",
            status: "",
            verticalId: 0,
            _isNew: true,
            isEditable: true
        },
        "Employees": {
            empId: 0,
            name: "",
            department: "",
            position: "",
            email: "",
            phone: "",
            status: "",
            _isNew: true,
            isEditable: true
        },
        "Opportunities": {
            oppId: 0,
            name: "",
            customerId: 0,
            value: 0,
            stage: "",
            probability: 0,
            closeDate: null,
            _isNew: true,
            isEditable: true
        },
        "Projects": {
            projId: 0,
            name: "",
            customerId: 0,
            startDate: null,
            endDate: null,
            status: "",
            budget: 0,
            _isNew: true,
            isEditable: true
        },
        "SAPIdStatuses": {
            sapId: 0,
            status: "",
            description: "",
            lastUpdated: null,
            _isNew: true,
            isEditable: true
        }
    };
    
    return emptyDataMap[sTableId] || {};
},
```

3) _resolveContextByPath function (CustomUtility.js)
```javascript
_resolveContextByPath: function (oTable, sPath) {
    console.log("Resolving context by path:", sPath);
    
    try {
        // Method 1: Try to get from binding contexts
        const oBinding = oTable.getRowBinding() || oTable.getBinding("items") || oTable.getBinding("rows");
        if (oBinding) {
            const aContexts = oBinding.getContexts();
            const oContext = aContexts.find(ctx => ctx.getPath() === sPath);
            if (oContext) {
                console.log("Context found via binding contexts");
                return oContext;
            }
        }
        
        // Method 2: Try to get from inner responsive table
        const oInnerTable = oTable.getTable ? oTable.getTable() : null;
        if (oInnerTable) {
            const oInnerBinding = oInnerTable.getBinding("items");
            if (oInnerBinding) {
                const aInnerContexts = oInnerBinding.getContexts();
                const oInnerContext = aInnerContexts.find(ctx => ctx.getPath() === sPath);
                if (oInnerContext) {
                    console.log("Context found via inner table contexts");
                    return oInnerContext;
                }
            }
        }
        
        console.log("Context not found for path:", sPath);
        return null;
    } catch (error) {
        console.error("Error resolving context:", error);
        return null;
    }
},
```

4) Controller wiring (Home.controller.js)
```javascript
// Add these method mappings to Home.controller.js
onAdd: CustomUtility.prototype.onAdd,
onSaveButtonPress: CustomUtility.prototype.onSaveButtonPress,
onCancelButtonPress: CustomUtility.prototype.onCancelButtonPress,
_createEmptyRowData: CustomUtility.prototype._createEmptyRowData,
_executeAddWithRetry: CustomUtility.prototype._executeAddWithRetry,
_resolveContextByPath: CustomUtility.prototype._resolveContextByPath,
_getRowBinding: CustomUtility.prototype._getRowBinding
```

5) Multi-row Save logic (onSaveButtonPress - CustomUtility.js)
```javascript
// 🚀 MULTI-ROW SAVE: Handle single, multi-edit, and multi-add
let aContextsToSave = [];

if ((sMode === "multi-edit" || sMode === "add-multi") && sPath.includes(",")) {
    // Multi-row editing or multi-add: resolve all contexts from paths
    const aPaths = sPath.split(",").filter(Boolean);
    aContextsToSave = aPaths.map(p => this._resolveContextByPath(oTable, p)).filter(Boolean);
    console.log(`=== [MULTI-SAVE] Saving ${aContextsToSave.length} rows (Mode: ${sMode}) ===`);
} else {
    // Single row editing or single add: find the specific context
    let oContext = this._resolveContextByPath(oTable, sPath);
    if (!oContext) {
        // As a fallback, use first selected
        const aSelectedContexts = oTable.getSelectedContexts();
        oContext = aSelectedContexts && aSelectedContexts[0];
    }
    if (!oContext) {
        sap.m.MessageBox.error("Unable to find edited context.");
        return;
    }
    aContextsToSave = [oContext];
    console.log(`=== [SINGLE-SAVE] Saving 1 row (Mode: ${sMode}) ===`);
}
```

6) Multi-row Cancel logic (onCancelButtonPress - CustomUtility.js)
```javascript
// 🚀 MULTI-ROW CANCEL: Handle single, multi-edit, and multi-add
let aContextsToCancel = [];

if ((sMode === "multi-edit" || sMode === "add-multi") && sPath.includes(",")) {
    // Multi-row editing or multi-add: resolve all contexts from paths
    const aPaths = sPath.split(",").filter(Boolean);
    aContextsToCancel = aPaths.map(p => self._resolveContextByPath(oTable, p)).filter(Boolean);
    console.log(`=== [MULTI-CANCEL] Canceling ${aContextsToCancel.length} rows (Mode: ${sMode}) ===`);
} else {
    // Single row editing or single add: resolve the specific context reliably
    let oContext = self._resolveContextByPath(oTable, sPath);
    if (!oContext) {
        const aSelectedContexts = oTable.getSelectedContexts();
        oContext = aSelectedContexts && aSelectedContexts.find(ctx => ctx.getPath() === sPath) || aSelectedContexts && aSelectedContexts[0];
    }
    if (!oContext) {
        sap.m.MessageToast.show("Unable to find edited context.");
        return;
    }
    aContextsToCancel = [oContext];
    console.log(`=== [SINGLE-CANCEL] Canceling 1 row (Mode: ${sMode}) ===`);
}

// Process ALL contexts to cancel
aContextsToCancel.forEach((oContext, index) => {
    console.log(`[MULTI-CANCEL] Processing row ${index + 1}: ${oContext.getPath()}`);
    
    const oData = oContext.getObject();
    
    // Handle new rows (transient or marked as new)
    if (oData._isNew || (typeof oContext.isTransient === "function" && oContext.isTransient())) {
        try {
            oContext.delete();
            console.log(`[MULTI-CANCEL] Deleted new/transient row ${index + 1}`);
        } catch (e) {
            console.log(`[MULTI-CANCEL] Error deleting transient row: ${e.message}`);
        }
        return; // Skip to next row
    }
    
    // Handle existing rows with original data
    if (oData._originalData) {
        console.log(`[MULTI-CANCEL] Restoring original data for row ${index + 1}...`);
        const oOriginalData = oData._originalData;
        
        // Restore all original properties
        Object.keys(oOriginalData).forEach(sKey => {
            if (sKey !== '_originalData' && sKey !== 'isEditable' && sKey !== '_hasChanged') {
                let vValue = oOriginalData[sKey];
                if (vValue instanceof Date) {
                    vValue = new Date(vValue.getTime());
                }
                oContext.setProperty(sKey, vValue);
            }
        });

        // Clean up the temporary properties
        delete oData._originalData;
        delete oData._hasChanged;
        delete oData.isEditable;
        
        console.log(`[MULTI-CANCEL] Restored original data for row ${index + 1}`);
    }
});
```
